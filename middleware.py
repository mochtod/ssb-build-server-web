#!/usr/bin/env python3
"""
Middleware Module for SSB Build Server Web Flask Application.

This module provides middleware functions and decorators for the Flask application:
- Request logging with unique IDs
- Performance tracking for routes
- Error handling and standardized error responses
- Role-based access control
- API response formatting

The middleware functions integrate with the error_handler and logger modules
to provide consistent error handling and logging across the application.
"""
import time
import json
import uuid
import traceback
import functools
from datetime import datetime
from flask import request, session, g, jsonify, make_response, redirect, url_for, flash, current_app

# Import our custom modules
try:
    from config import config
    from logger import get_logger, set_context, clear_context, context
    from error_handler import (
        AppError, ValidationError, AuthenticationError, AuthorizationError,
        ResourceNotFoundError, format_error_response, create_flash_message
    )
except ImportError:
    # Fall back to basic functionality if modules are not available
    import logging
    config = None
    get_logger = lambda name: logging.getLogger(name)
    set_context = lambda **kwargs: None
    clear_context = lambda: None
    context = lambda **kwargs: contextlib.nullcontext()
    
    # Define error classes if error_handler is not available
    class AppError(Exception):
        pass
    class ValidationError(AppError):
        pass
    class AuthenticationError(AppError):
        pass
    class AuthorizationError(AppError):
        pass
    class ResourceNotFoundError(AppError):
        pass
    
    # Simple implementation of error formatting functions
    def format_error_response(error, include_traceback=False):
        response = {
            'error': True,
            'error_type': error.__class__.__name__,
            'message': str(error)
        }
        if include_traceback:
            response['traceback'] = traceback.format_exc()
        return response
    
    def create_flash_message(error):
        return f"Error: {str(error)}", "error"

# Get logger for this module
logger = get_logger('middleware')

def init_middleware(app):
    """
    Initialize middleware for the Flask application.
    
    Args:
        app: Flask application instance
    """
    logger.info("Initializing application middleware")
    
    # Register before request handler
    @app.before_request
    def before_request():
        """Process request before it's handled by a route."""
        # Generate a unique request ID
        request_id = str(uuid.uuid4())
        g.request_id = request_id
        
        # Set up request timing
        g.request_start_time = time.time()
        
        # Set up request context for logging
        set_context(
            request_id=request_id,
            url=request.path,
            method=request.method,
            ip=request.remote_addr,
            user_agent=request.user_agent.string,
            user=session.get('username', 'anonymous')
        )
        
        # Log the request
        logger.info(f"Request started: {request.method} {request.path}")
    
    # Register after request handler
    @app.after_request
    def after_request(response):
        """Process response after it's generated by a route."""
        # Calculate request duration
        if hasattr(g, 'request_start_time'):
            duration_ms = (time.time() - g.request_start_time) * 1000
            response.headers['X-Request-Time-Ms'] = str(int(duration_ms))
            
            # Log the response
            status_code = response.status_code
            logger.info(
                f"Request completed: {request.method} {request.path} - Status: {status_code}, "
                f"Duration: {duration_ms:.2f}ms"
            )
        
        # Add request ID header if available
        if hasattr(g, 'request_id'):
            response.headers['X-Request-ID'] = g.request_id
        
        # Clean up request context
        clear_context()
        
        return response
    
    # Register error handlers
    register_error_handlers(app)
    
    logger.info("Middleware initialization complete")

def register_error_handlers(app):
    """
    Register error handlers for the Flask application.
    
    Args:
        app: Flask application instance
    """
    # Handle 404 Not Found errors
    @app.errorhandler(404)
    def not_found_error(error):
        """Handle 404 Not Found errors."""
        logger.warning(f"Not Found: {request.path}")
        
        # Check if JSON is requested
        if request.headers.get('Content-Type') == 'application/json' or request.headers.get('Accept') == 'application/json':
            return jsonify(format_error_response(ResourceNotFoundError(f"Resource not found: {request.path}"))), 404
        
        # Flash error message for HTML response
        flash(f"The requested page was not found: {request.path}", "error")
        return redirect(url_for('index'))
    
    # Handle 500 Internal Server Error
    @app.errorhandler(500)
    def internal_error(error):
        """Handle 500 Internal Server Error."""
        logger.error(f"Internal Server Error: {str(error)}", exc_info=True)
        
        # Check if JSON is requested
        if request.headers.get('Content-Type') == 'application/json' or request.headers.get('Accept') == 'application/json':
            # Include traceback in development mode
            include_traceback = app.debug
            return jsonify(format_error_response(error, include_traceback)), 500
        
        # Flash error message for HTML response
        flash("An internal server error occurred. Please try again later.", "error")
        return redirect(url_for('index'))
    
    # Handle application-specific errors
    @app.errorhandler(AppError)
    def app_error(error):
        """Handle application-specific errors."""
        # Determine appropriate status code based on error type
        status_code = 500
        if isinstance(error, ValidationError):
            status_code = 400
        elif isinstance(error, AuthenticationError):
            status_code = 401
        elif isinstance(error, AuthorizationError):
            status_code = 403
        elif isinstance(error, ResourceNotFoundError):
            status_code = 404
        
        # Log the error
        logger.error(f"Application Error ({error.__class__.__name__}): {str(error)}")
        
        # Check if JSON is requested
        if request.headers.get('Content-Type') == 'application/json' or request.headers.get('Accept') == 'application/json':
            return jsonify(format_error_response(error)), status_code
        
        # Flash error message for HTML response
        message, category = create_flash_message(error)
        flash(message, category)
        
        # Redirect to login for authentication errors
        if isinstance(error, AuthenticationError):
            return redirect(url_for('login', next=request.url))
        
        # Redirect to index for other errors
        return redirect(url_for('index'))

# Role-based access control decorator
def role_required(role):
    """
    Decorator for routes that require a specific role.
    
    Args:
        role: Required role for the route
        
    Returns:
        Decorated function
    """
    def decorator(f):
        @functools.wraps(f)
        def decorated_function(*args, **kwargs):
            # Check if user is logged in
            if 'username' not in session:
                logger.warning(f"Unauthorized access attempt to {request.path} (not logged in)")
                if request.headers.get('Content-Type') == 'application/json' or request.headers.get('Accept') == 'application/json':
                    return jsonify(format_error_response(AuthenticationError("Authentication required"))), 401
                
                flash("Please log in to access this page", 'error')
                return redirect(url_for('login', next=request.url))
            
            # Check if user has required role
            if 'role' not in session or session['role'] != role:
                username = session.get('username', 'unknown')
                user_role = session.get('role', 'none')
                logger.warning(f"Unauthorized access attempt to {request.path} by {username} (role: {user_role}, required: {role})")
                
                if request.headers.get('Content-Type') == 'application/json' or request.headers.get('Accept') == 'application/json':
                    return jsonify(format_error_response(AuthorizationError(f"Required role: {role}"))), 403
                
                flash(f"You need {role} privileges to access this page", 'error')
                return redirect(url_for('index'))
            
            # User has required role, proceed with the route
            return f(*args, **kwargs)
        return decorated_function
    return decorator

# Login required decorator with enhanced logging
def login_required(f):
    """
    Decorator for routes that require authentication.
    
    Args:
        f: Function to decorate
        
    Returns:
        Decorated function
    """
    @functools.wraps(f)
    def decorated_function(*args, **kwargs):
        # Check if user is logged in
        if 'username' not in session:
            logger.warning(f"Unauthorized access attempt to {request.path} (not logged in)")
            
            if request.headers.get('Content-Type') == 'application/json' or request.headers.get('Accept') == 'application/json':
                return jsonify(format_error_response(AuthenticationError("Authentication required"))), 401
            
            flash("Please log in to access this page", 'error')
            return redirect(url_for('login', next=request.url))
        
        # User is logged in, proceed with the route
        return f(*args, **kwargs)
    return decorated_function

# API response formatter
def api_response(f):
    """
    Decorator for formatting API responses.
    
    Args:
        f: Function to decorate
        
    Returns:
        Decorated function
    """
    @functools.wraps(f)
    def decorated_function(*args, **kwargs):
        try:
            # Call the route function
            result = f(*args, **kwargs)
            
            # Check if result is already a Response object
            if isinstance(result, (current_app.response_class, current_app.json.response_class)):
                return result
            
            # If result is a tuple of (data, status_code), unpack it
            status_code = 200
            if isinstance(result, tuple) and len(result) == 2:
                result, status_code = result
            
            # Format the response
            response_data = {
                'success': True,
                'data': result,
                'timestamp': datetime.now().isoformat(),
                'request_id': getattr(g, 'request_id', None)
            }
            
            return jsonify(response_data), status_code
            
        except Exception as e:
            # Handle errors in the route
            logger.error(f"Error in API route {request.path}: {str(e)}", exc_info=True)
            
            # Format the error response
            status_code = 500
            if isinstance(e, ValidationError):
                status_code = 400
            elif isinstance(e, AuthenticationError):
                status_code = 401
            elif isinstance(e, AuthorizationError):
                status_code = 403
            elif isinstance(e, ResourceNotFoundError):
                status_code = 404
            
            response_data = format_error_response(e, include_traceback=current_app.debug)
            response_data['timestamp'] = datetime.now().isoformat()
            response_data['request_id'] = getattr(g, 'request_id', None)
            
            return jsonify(response_data), status_code
    
    return decorated_function

# Request timing decorator
def log_timing(f):
    """
    Decorator for logging request timing.
    
    Args:
        f: Function to decorate
        
    Returns:
        Decorated function
    """
    @functools.wraps(f)
    def decorated_function(*args, **kwargs):
        # Get route name
        route_name = f.__name__
        
        # Start timing
        start_time = time.time()
        logger.info(f"Starting route {route_name}")
        
        try:
            # Call the route function
            result = f(*args, **kwargs)
            
            # Calculate duration
            duration_ms = (time.time() - start_time) * 1000
            logger.info(f"Completed route {route_name} in {duration_ms:.2f}ms")
            
            return result
            
        except Exception as e:
            # Calculate duration even if there's an error
            duration_ms = (time.time() - start_time) * 1000
            logger.error(f"Error in route {route_name} after {duration_ms:.2f}ms: {str(e)}", exc_info=True)
            raise
    
    return decorated_function

# Combined middleware decorator for API routes
def api_route(role=None):
    """
    Combined decorator for API routes.
    
    Args:
        role: Required role for the route (optional)
        
    Returns:
        Decorator function
    """
    def decorator(f):
        # Apply decorators in the correct order (inside to outside)
        decorated = log_timing(f)
        decorated = api_response(decorated)
        
        if role:
            decorated = role_required(role)(decorated)
        else:
            decorated = login_required(decorated)
        
        return decorated
    
    return decorator

# Form validation decorator
def validate_form(*required_fields):
    """
    Decorator for validating form data.
    
    Args:
        *required_fields: List of required form fields
        
    Returns:
        Decorator function
    """
    def decorator(f):
        @functools.wraps(f)
        def decorated_function(*args, **kwargs):
            # Check if request has form data
            if not request.form:
                logger.warning("Form validation failed: No form data submitted")
                raise ValidationError("No form data submitted")
            
            # Check required fields
            missing_fields = [field for field in required_fields if field not in request.form or not request.form[field]]
            if missing_fields:
                logger.warning(f"Form validation failed: Missing required fields: {', '.join(missing_fields)}")
                raise ValidationError(f"Missing required fields: {', '.join(missing_fields)}")
            
            # Form is valid, proceed with the route
            return f(*args, **kwargs)
        
        return decorated_function
    
    return decorator
